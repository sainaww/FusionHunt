############### perl script to detect fusion transcripts using alignments generated by BLAT. Script is #################
############### file format specific. ##################################################################################

package compartment_B::DetectChimera;

use strict;
use warnings;

use compartment_B::DetectRightChimerasSR;
use compartment_B::DetectLeftChimerasSR;
use compartment_B::ChimerDetectionCommonModules;

	sub detect_chimeric_transcripts{
	my($chimerType,$cutoffHashRef,$pslx2IndxRef,$clustRef,$outFilesRef) = @_;

	#### miscellaneous cutoffs ####
	my $repeatIdentityCutoff = 90.0;  ## identity cutoff to call two alignmets as repetitive (if more than one alignments are found for same (almost) query part)
	my $scoreCutoff = 20;  ## alignment score cutoff on each fragment
	my $qLenCutoff = 50;  ## minimal length of the query sequence to determine chimeric transcripts
	###############################
	my(@covCluster);
	my($topMultiNum);
	my($alignmentScreenTag,@qualifiedAlignments);
	my($chimerFlag,@chimerArray);  ## variables to be returned
	$chimerFlag = 0;
	splice(@chimerArray);

		if(scalar(@{$clustRef}) == 1){  ## if there is only one hit for the read
		shared::FileCheckPrint::print_cluster_to_file($outFilesRef->{"Discarded"},scalar(keys(%{$pslx2IndxRef})),1,$clustRef);
		}
		elsif(scalar(@{$clustRef}) > 1){  ## if there are more than one alignments
			if(compartment_B::ChimerDetectionCommonModules::check_top_hit_multi($repeatIdentityCutoff,\$topMultiNum,$clustRef,$pslx2IndxRef)){  ## if top multi hits found
			##print "\ntopMultiFlag: $topMultiNum\n";
			##shared::FileCheckPrint::print_cluster_to_file($outFilesRef->{"Discarded"},scalar(keys(%{$pslx2IndxRef})),1,$clustRef);
			}
			else{
				if($chimerType eq "Right"){
				@covCluster = compartment_B::DetectRightChimerasSR::define_potential_right_chimers($cutoffHashRef->{"RightLeaveCutoff"},$repeatIdentityCutoff,$scoreCutoff,$qLenCutoff,$pslx2IndxRef,$clustRef);
				}
				elsif($chimerType eq "Left"){
				@covCluster = compartment_B::DetectLeftChimerasSR::define_potential_left_chimers($cutoffHashRef->{"LeftLeaveCutoff"},$repeatIdentityCutoff,$scoreCutoff,$qLenCutoff,$pslx2IndxRef,$clustRef);
				}

				if(scalar(@covCluster)){  ## if there are any filling gaps
				$alignmentScreenTag = compartment_B::ChimerDetectionCommonModules::screen_alignments($cutoffHashRef->{"IdentityCutoff"},$repeatIdentityCutoff,$pslx2IndxRef,$clustRef,\@covCluster,\@qualifiedAlignments);

					if( ($alignmentScreenTag eq "Recombination") || ($alignmentScreenTag eq "SameRecombination") ){  ## if chimeric transcript found
					$chimerFlag = 1;
						if($chimerType eq "Right"){
						@chimerArray = compartment_B::DetectRightChimerasSR::print_right_chimeras_to_file($pslx2IndxRef,$clustRef,\@covCluster,\@qualifiedAlignments);
						}  ## if($chimerType eq "Right") ends
						else{
						@chimerArray = compartment_B::DetectLeftChimerasSR::print_left_chimeras_to_file($pslx2IndxRef,$clustRef,\@covCluster,\@qualifiedAlignments);
						}
					}  ## if($alignmentTag eq recombination) ends

					else{  ## if(no recombination), discarded
					##shared::FileCheckPrint::print_cluster_to_file($outFilesRef->{"Discarded"},scalar(keys(%{$pslx2IndxRef})),1,$clustRef);
					}  ## discarding if not chimeric transcript
				}  ## if(@covCluster) ends
				else{  ## no filling alignment found
				##shared::FileCheckPrint::print_cluster_to_file($outFilesRef->{"Discarded"},scalar(keys(%{$pslx2IndxRef})),1,$clustRef);  ## printing to file
				}  ## else ends
			}  ## if(no multiple gap ends)
		}  ## elsif($n>1) ends
	shared::DeleteDataStructures::undefine_arrays(\@covCluster,\@qualifiedAlignments);
	return($chimerFlag,@chimerArray);  ## returning variables
	}  ## function ends
	###########################
1;
